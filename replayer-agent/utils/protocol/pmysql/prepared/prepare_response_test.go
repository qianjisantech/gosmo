package prepared

import (
	"bytes"
	"testing"

	"github.com/didi/sharingan/replayer-agent/utils/protocol/pmysql/command"

	"github.com/modern-go/parse"
	"github.com/stretchr/testify/require"
)

func TestDecodePrepareResponse(t *testing.T) {
	var testCase = []struct {
		raw    []byte
		expect *PrepareResponse
	}{
		{
			raw: []byte{
				0x0c, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x02, 0x03, 0x64, 0x65, 0x66, 0x00, 0x00, 0x00, 0x01,
				0x3f, 0x00, 0x0c, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfd, 0x80, 0x00,
				0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x03, 0x03, 0x64, 0x65, 0x66, 0x00, 0x00, 0x00, 0x01,
				0x3f, 0x00, 0x0c, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfd, 0x80, 0x00,
				0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x04, 0x03, 0x64, 0x65, 0x66, 0x00, 0x00, 0x00, 0x01,
				0x3f, 0x00, 0x0c, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfd, 0x80, 0x00,
				0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x05, 0xfe, 0x00, 0x00, 0x02, 0x00, 0x32, 0x00, 0x00, 0x06, 0x03, 0x64, 0x65, 0x66, 0x04, 0x74, 0x65, 0x73,
				0x74, 0x0a, 0x64, 0x65, 0x70, 0x61, 0x72, 0x74, 0x6d, 0x65, 0x6e, 0x74,
				0x0a, 0x64, 0x65, 0x70, 0x61, 0x72, 0x74, 0x6d, 0x65, 0x6e, 0x74, 0x02,
				0x69, 0x64, 0x02, 0x69, 0x64, 0x0c, 0x3f, 0x00, 0x0a, 0x00, 0x00, 0x00,
				0x03, 0x03, 0x42, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x07, 0x03, 0x64, 0x65, 0x66, 0x04, 0x74, 0x65, 0x73,
				0x74, 0x0a, 0x64, 0x65, 0x70, 0x61, 0x72, 0x74, 0x6d, 0x65, 0x6e, 0x74,
				0x0a, 0x64, 0x65, 0x70, 0x61, 0x72, 0x74, 0x6d, 0x65, 0x6e, 0x74, 0x04,
				0x6e, 0x61, 0x6d, 0x65, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x0c, 0x21, 0x00,
				0x3c, 0x00, 0x00, 0x00, 0xfd, 0x01, 0x10, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x08, 0x03, 0x64, 0x65, 0x66, 0x04, 0x74, 0x65, 0x73,
				0x74, 0x0a, 0x64, 0x65, 0x70, 0x61, 0x72, 0x74, 0x6d, 0x65, 0x6e, 0x74,
				0x0a, 0x64, 0x65, 0x70, 0x61, 0x72, 0x74, 0x6d, 0x65, 0x6e, 0x74, 0x03,
				0x61, 0x67, 0x65, 0x03, 0x61, 0x67, 0x65, 0x0c, 0x3f, 0x00, 0x0a, 0x00,
				0x00, 0x00, 0x03, 0x01, 0x10, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x09, 0x03, 0x64, 0x65, 0x66, 0x04, 0x74, 0x65, 0x73,
				0x74, 0x0a, 0x64, 0x65, 0x70, 0x61, 0x72, 0x74, 0x6d, 0x65, 0x6e, 0x74,
				0x0a, 0x64, 0x65, 0x70, 0x61, 0x72, 0x74, 0x6d, 0x65, 0x6e, 0x74, 0x06,
				0x73, 0x61, 0x6c, 0x61, 0x72, 0x79, 0x06, 0x73, 0x61, 0x6c, 0x61, 0x72,
				0x79, 0x0c, 0x3f, 0x00, 0x0a, 0x00, 0x00, 0x00, 0xf6, 0x01, 0x10, 0x02,
				0x00, 0x00, 0x05, 0x00, 0x00, 0x0a, 0xfe, 0x00, 0x00, 0x02, 0x00,
			},
			expect: &PrepareResponse{
				StatementID:  2,
				ColumnNumber: 4,
				ParamNumber:  3,
				Warnings:     0,
				ColumnDef: []command.Columndef{
					{
						Schema:     "test",
						Table:      "department",
						OrgTable:   "department",
						ColName:    "id",
						OrgColName: "id",
						Charset:    0x3f,
						ColLength:  10,
						Type:       0x03,
						ExtraBytes: []byte{0x03, 0x42, 0, 0, 0},
					},
					{
						Schema:     "test",
						Table:      "department",
						OrgTable:   "department",
						ColName:    "name",
						OrgColName: "name",
						Charset:    0x21,
						ColLength:  60,
						Type:       0xfd,
						ExtraBytes: []byte{0x01, 0x10, 0, 0, 0},
					},
					{
						Schema:     "test",
						Table:      "department",
						OrgTable:   "department",
						ColName:    "age",
						OrgColName: "age",
						Charset:    0x3f,
						ColLength:  10,
						Type:       0x03,
						ExtraBytes: []byte{0x01, 0x10, 0, 0, 0},
					},
					{
						Schema:     "test",
						Table:      "department",
						OrgTable:   "department",
						ColName:    "salary",
						OrgColName: "salary",
						Charset:    0x3f,
						ColLength:  10,
						Type:       0xf6,
						ExtraBytes: []byte{0x01, 0x10, 0x02, 0, 0},
					},
				},
			},
		},
	}
	should := require.New(t)
	for idx, tc := range testCase {
		src, err := parse.NewSource(bytes.NewReader(tc.raw), 10)
		should.NoError(err)
		actual, err := DecodePrepareResponse(src)

		should.NoError(err, "case #%d fail", idx)
		should.Equal(tc.expect, actual, "case #%d fail", idx)
	}
}
