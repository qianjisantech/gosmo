package agent

import (
	"agent/internal/common/errorx"
	"agent/internal/env"
	"bufio"
	"bytes"
	"context"
	"crypto/md5"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os/exec"
	"strconv"
	"strings"
	"time"

	"agent/internal/svc"
	"agent/internal/types"

	"github.com/zeromicro/go-zero/core/logx"
)

type AgentRunLogic struct {
	logx.Logger
	ctx    context.Context
	svcCtx *svc.ServiceContext
}

func NewAgentRunLogic(ctx context.Context, svcCtx *svc.ServiceContext) *AgentRunLogic {
	return &AgentRunLogic{
		Logger: logx.WithContext(ctx),
		ctx:    ctx,
		svcCtx: svcCtx,
	}
}

func (l *AgentRunLogic) AgentRun(req *types.AgentRunRequest) (resp *types.AgentRunResp, err error) {
	// 1. ç¡®ä¿ç´¢å¼•æ¨¡æ¿å­˜åœ¨ï¼ˆåŒæ­¥æ“ä½œï¼Œå¿…é¡»ç«‹å³æ£€æŸ¥ï¼‰
	if err := l.createIndexTemplate(); err != nil {
		return nil, errorx.NewDefaultError("æ— æ³•åˆ›å»ºç´¢å¼•æ¨¡æ¿: %v" + err.Error())
	}
	gorPath, err := env.GetGorPath()
	// 2. å¯åŠ¨ gor è¿›ç¨‹
	cmd := exec.Command(gorPath,
		"--input-raw", ":8888",
		"--input-raw-track-response",
		"-output-http-track-response",
		"--output-stdout")

	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return nil, errorx.NewDefaultError("åˆ›å»ºstdoutç®¡é“å¤±è´¥:" + err.Error())
	}

	if err := cmd.Start(); err != nil {
		return nil, errorx.NewDefaultError("å¯åŠ¨GoReplayå¤±è´¥:" + err.Error())
	}

	// 3. å¼‚æ­¥å¤„ç†æ•°æ®æµï¼ˆä¸é˜»å¡ä¸»çº¿ç¨‹ï¼‰
	go func() {
		defer cmd.Process.Kill() // ç¡®ä¿è¿›ç¨‹é€€å‡ºæ—¶è¢«æ¸…ç†
		l.processStream(stdout)
	}()

	// 4. ç«‹å³è¿”å›æˆåŠŸ
	return &types.AgentRunResp{
		Success: true,
		Message: "GoReplayå·²å¯åŠ¨ï¼Œæ­£åœ¨å¼‚æ­¥å¤„ç†æµé‡",
	}, nil
}

type Request struct {
	Method  string            `json:"method"`
	URL     string            `json:"url"`
	Headers map[string]string `json:"headers"`
	Body    string            `json:"body"`
}

type Response struct {
	Status  int               `json:"status"`
	Headers map[string]string `json:"headers"`
	Body    string            `json:"body"`
}

type RequestResponse struct {
	RequestID string            `json:"request_id"`
	Timestamp time.Time         `json:"@timestamp"`
	Request   Request           `json:"request"`
	Response  Response          `json:"response"`
	Metadata  map[string]string `json:"metadata,omitempty"`
}

func (l *AgentRunLogic) createIndexTemplate() error {
	template := `{
		"index_patterns": ["gosmo-*"],  // ä¿®æ”¹ä¸ºå®é™…ä½¿ç”¨çš„ç´¢å¼•æ¨¡å¼
		"priority": 100,                // è®¾ç½®é«˜ä¼˜å…ˆçº§ç¡®ä¿æ¨¡æ¿ç”Ÿæ•ˆ
		"template": {
			"mappings": {
				"dynamic": false,
				"properties": {
					"@timestamp": {"type": "date"},
					"request_id": {"type": "keyword"},
					"request": {
						"properties": {
							"method": {"type": "keyword"},
							"url": {
								"type": "text",
								"fields": {"keyword": {"type": "keyword"}}
							},
							"body": {"type": "text"},
							"headers": {"type": "object", "enabled": true}  // ä½¿ç”¨ç®€å•objectç±»å‹
						}
					},
					"response": {
						"properties": {
							"status": {"type": "integer"},
							"body": {"type": "text"},
							"headers": {"type": "object", "enabled": true}  // ä½¿ç”¨ç®€å•objectç±»å‹
						}
					},
					"metadata": {
						"properties": {
							"source": {"type": "keyword"},
							"host": {"type": "keyword"},
							"user_agent": {"type": "keyword"},
							"timestamp": {"type": "date"}
						}
					}
				}
			},
			"settings": {
				"number_of_shards": 1,
				"number_of_replicas": 0
			}
		}
	}`

	//// å…ˆåˆ é™¤æ—§æ¨¡æ¿ï¼ˆå¯é€‰ï¼‰
	//http.DefaultClient.Do(&http.Request{
	//	Method: "DELETE",
	//	URL:    l.parseURL("http://47.94.96.190:9200/_index_template/gosmo-template"),
	//})

	resp, err := http.Post(
		l.svcCtx.Config.ElasticSearch.Host+"/_index_template/gosmo-template",
		"application/json",
		bytes.NewBufferString(template),
	)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("åˆ›å»ºæ¨¡æ¿å¤±è´¥: %s", string(body))
	}

	log.Println("ç´¢å¼•æ¨¡æ¿åˆ›å»º/æ›´æ–°æˆåŠŸ")
	return nil
}

const (
	phaseStart = iota
	phaseHeaders
	phaseBody
)

func (l *AgentRunLogic) processStream(stdout io.ReadCloser) {
	scanner := bufio.NewScanner(stdout)
	scanner.Buffer(make([]byte, 1024*1024), 10*1024*1024)

	var (
		currentReq   *Request
		currentResp  *Response
		isRequest    bool
		bodyBuffer   bytes.Buffer // æ”¹ç”¨ bytes.Buffer æ›´é«˜æ•ˆå¤„ç† body
		reqStartTime time.Time
		parsingPhase = phaseStart // ä½¿ç”¨çŠ¶æ€æœºæ›¿ä»£å¸ƒå°”æ ‡è®°
		expectBody   bool
	)

	for scanner.Scan() {
		line := scanner.Text()

		switch {
		case strings.HasPrefix(line, "1 "), strings.HasPrefix(line, "2 "):
			// å¤„ç†ä¹‹å‰å®Œæˆçš„è¯·æ±‚-å“åº”å¯¹
			if currentReq != nil && currentResp != nil {
				log.Printf("")
				l.finalizeBody(&bodyBuffer, isRequest, currentReq, currentResp)
				l.processCompletedPair(currentReq, currentResp, reqStartTime)
			}

			// åˆå§‹åŒ–æ–°è¯·æ±‚/å“åº”
			if strings.HasPrefix(line, "1 ") {
				currentReq = &Request{Headers: make(map[string]string)}
				isRequest = true
				reqStartTime = time.Now().UTC()
			} else {
				currentResp = &Response{Headers: make(map[string]string)}
				isRequest = false
			}
			bodyBuffer.Reset()
			parsingPhase = phaseHeaders
			expectBody = false

			// è§£æèµ·å§‹è¡Œ
			l.parseStartLine(line, isRequest, currentReq, currentResp)

		case line == "":
			// ç©ºè¡Œè¡¨ç¤º headers ç»“æŸ
			if parsingPhase == phaseHeaders {
				parsingPhase = phaseBody
				expectBody = l.shouldExpectBody(isRequest, currentReq, currentResp)
			} else {
				// ç©ºè¡Œä½œä¸º body çš„ä¸€éƒ¨åˆ†ï¼ˆå¦‚ multipart/form-dataï¼‰
				if expectBody {
					bodyBuffer.WriteString("\n") // ä¿ç•™åŸå§‹ç©ºè¡Œ
				}
			}

		default:
			switch parsingPhase {
			case phaseHeaders:
				l.parseHeaderLine(line, isRequest, currentReq, currentResp)
			case phaseBody:
				if expectBody {
					if bodyBuffer.Len() > 0 {
						bodyBuffer.WriteString("\n") // æ·»åŠ æ¢è¡Œç¬¦åˆ†éš”å¤šè¡Œ
					}
					bodyBuffer.WriteString(line)
				}
			}
		}
	}

	// å¤„ç†æœ€åä¸€æ¡è®°å½•
	if currentReq != nil && currentResp != nil {
		l.finalizeBody(&bodyBuffer, isRequest, currentReq, currentResp)
		l.processCompletedPair(currentReq, currentResp, reqStartTime)
	}

	if err := scanner.Err(); err != nil {
		log.Printf("æ‰«æé”™è¯¯: %v", err)
	}
}

func (l *AgentRunLogic) parseStartLine(line string, isRequest bool, req *Request, resp *Response) {
	parts := strings.SplitN(line, " ", 3)
	if len(parts) < 3 {
		return
	}

	if isRequest {
		// å®Œæ•´è§£æè¯·æ±‚è¡Œ: METHOD URI PROTOCOL
		req.Method = parts[0]

		// æå–å®Œæ•´URLï¼ˆåŒ…æ‹¬æŸ¥è¯¢å‚æ•°ï¼‰
		if u, err := url.Parse(parts[1]); err == nil {
			req.URL = u.Path
			if u.RawQuery != "" {
				req.URL += "?" + u.RawQuery
			}
		} else {
			req.URL = parts[1] // å›é€€æ–¹æ¡ˆ
		}
	} else {
		// å“åº”è¡Œ: PROTOCOL STATUS REASON
		if strings.HasPrefix(parts[0], "HTTP/") {
			status, _ := strconv.Atoi(parts[1])
			resp.Status = status
		}
	}
}

// è§£æå¤´å­—æ®µ
func (l *AgentRunLogic) parseHeaderLine(line string, isRequest bool, req *Request, resp *Response) {
	if idx := strings.Index(line, ":"); idx > 0 {
		key := strings.TrimSpace(line[:idx])
		value := strings.TrimSpace(line[idx+1:])
		if isRequest {
			req.Headers[key] = value
		} else {
			resp.Headers[key] = value
		}
	}
}

// åˆ¤æ–­æ˜¯å¦éœ€è¦è¯»å– body
func (l *AgentRunLogic) shouldExpectBody(isRequest bool, req *Request, resp *Response) bool {
	headers := req.Headers
	if !isRequest {
		headers = resp.Headers
	}

	// æ£€æŸ¥åˆ†å—ä¼ è¾“
	if te, ok := headers["Transfer-Encoding"]; ok && strings.Contains(strings.ToLower(te), "chunked") {
		return true
	}

	// æ£€æŸ¥å†…å®¹é•¿åº¦
	if cl, ok := headers["Content-Length"]; ok {
		if length, err := strconv.Atoi(cl); err == nil && length > 0 {
			return true
		}
	}

	// ç‰¹æ®Šè¯·æ±‚æ–¹æ³•å¯èƒ½æœ‰ body
	if isRequest && (req.Method == "POST" || req.Method == "PUT" || req.Method == "PATCH") {
		return true
	}

	return false
}

// æœ€ç»ˆå¤„ç† body å†…å®¹
func (l *AgentRunLogic) finalizeBody(bodyBuffer *bytes.Buffer, isRequest bool, req *Request, resp *Response) {
	body := bodyBuffer.String()
	// ç§»é™¤å¯èƒ½å­˜åœ¨çš„åˆ†éš”ç¬¦ï¼ˆé˜²å¾¡æ€§å¤„ç†ï¼‰
	body = strings.Split(body, "ğŸµğŸ™ˆğŸ™‰")[0]
	body = strings.TrimSpace(body)

	if isRequest && req != nil {
		req.Body = body
	} else if resp != nil {
		resp.Body = body
	}
}
func (l *AgentRunLogic) processCompletedPair(req *Request, resp *Response, timestamp time.Time) {
	if req == nil || resp == nil {
		return
	}

	// è§„èŒƒåŒ–URL
	if !strings.HasPrefix(req.URL, "/") && !strings.Contains(req.URL, "://") {
		req.URL = "/" + req.URL
	}

	rr := RequestResponse{
		RequestID: l.generateRequestID(),
		Timestamp: timestamp,
		Request:   *req,
		Response:  *resp,
		Metadata: map[string]string{
			"source":     "gor",
			"host":       l.getHostFromHeaders(req.Headers),
			"user_agent": req.Headers["User-Agent"],
			"timestamp":  timestamp.Format(time.RFC3339),
		},
	}

	if err := l.sendToElasticsearch(rr); err != nil {
		logx.Errorf("ESå†™å…¥å¤±è´¥: %v", err)
	}
}

func (l *AgentRunLogic) sendToElasticsearch(rr RequestResponse) error {
	// å‡†å¤‡æ–‡æ¡£æ•°æ®
	doc := map[string]interface{}{
		"request_id": rr.RequestID,
		"@timestamp": rr.Timestamp,
		"request": map[string]interface{}{
			"method":  rr.Request.Method,
			"url":     rr.Request.URL,
			"headers": rr.Request.Headers, // ç›´æ¥ä½¿ç”¨map
			"body":    rr.Request.Body,
		},
		"response": map[string]interface{}{
			"status":  rr.Response.Status,
			"headers": rr.Response.Headers, // ç›´æ¥ä½¿ç”¨map
			"body":    rr.Response.Body,
		},
		"metadata": rr.Metadata,
	}
	log.Printf("ä¼ å…¥esä¹‹å‰çš„æ•°æ®ä¸ºï¼š%v", doc)
	jsonData, err := json.Marshal(doc)

	if err != nil {
		return fmt.Errorf("JSONç¼–ç å¤±è´¥: %v", err)
	}

	indexName := "gosmo-" + time.Now().Format(time.DateOnly)
	docID := l.generateDocID(rr.Request.URL)
	url := fmt.Sprintf("%s/%s/_doc/%s", l.svcCtx.Config.ElasticSearch.Host, indexName, docID)

	req, err := http.NewRequest("PUT", url, bytes.NewReader(jsonData))
	if err != nil {
		return fmt.Errorf("åˆ›å»ºè¯·æ±‚å¤±è´¥: %v", err)
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return fmt.Errorf("è¯·æ±‚å¤±è´¥: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("ESè¿”å›é”™è¯¯: çŠ¶æ€ç =%d, å“åº”=%s", resp.StatusCode, string(body))
	}

	log.Printf("ç”Ÿæˆè¯·æ±‚---->IDä¸º %s, æˆåŠŸå†™å…¥ES: %s %s %s -> %d", rr.RequestID,
		rr.Request.Method, rr.Request.URL, rr.Response.Status)
	return nil
}

func (l *AgentRunLogic) generateDocID(reqURL string) string {
	// å…ˆå°è¯•è§£æURLè·å–pathéƒ¨åˆ†
	if u, err := url.Parse(reqURL); err == nil {
		reqURL = u.Path
	}

	h := md5.New()
	io.WriteString(h, reqURL)
	return fmt.Sprintf("%x", h.Sum(nil))
}

func (l *AgentRunLogic) generateRequestID() string {
	return fmt.Sprintf("%d", time.Now().UnixNano())
}

func (l *AgentRunLogic) getHostFromHeaders(headers map[string]string) string {
	if host, ok := headers["Host"]; ok {
		return host
	}
	return "unknown"
}

func (l *AgentRunLogic) parseURL(raw string) *url.URL {
	u, _ := url.Parse(raw)
	return u
}
